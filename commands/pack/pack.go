// Copyright (c) 2021 rookie-ninja
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file.
package pack

import (
	"errors"
	"fmt"
	"github.com/fatih/color"
	"github.com/rookie-ninja/rk-common/common"
	"github.com/rookie-ninja/rk/commands/build"
	"github.com/rookie-ninja/rk/common"
	"github.com/urfave/cli/v2"
	"os"
	"os/exec"
	"strings"
)

func Pack() *cli.Command {
	command := &cli.Command{
		Name:      "pack",
		Usage:     "Pack target folder generated by rk build",
		UsageText: "rk pack",
		Action:    packAction,
	}

	return command
}

func packAction(ctx *cli.Context) error {
	if err := common.UnmarshalBootConfig("build.yaml", common.BuildConfig); err != nil {
		return err
	}
	chain := common.NewActionChain()
	chain.Add("Clearing target folder", func(ctx *cli.Context) error {
		// 0: Not dir of where go.mod file exists
		if !rkcommon.FileExists("go.mod") {
			return errors.New("not a go directory, failed to lookup go.mod file")
		}
		return os.RemoveAll(common.BuildTarget)
	}, false)

	switch common.BuildConfig.Build.Type {
	case "go":
		chain.Add("Execute user command before", build.ExecCommandsBefore, false)
		chain.Add("Execute user script before", build.ExecScriptBefore, false)
		chain.Add("Build go file", build.BuildGoFile, false)
		chain.Add("Copy to target folder", build.CopyToTarget, false)
		chain.Add("Generate rk meta from on local", build.WriteRkMetaFile, false)
		chain.Add("Execute user script after", build.ExecScriptAfter, false)
		chain.Add("Execute user command after", build.ExecCommandsAfter, false)
	default:
		chain.Add("Execute user command before", build.ExecCommandsBefore, false)
		chain.Add("Execute user script before", build.ExecScriptBefore, false)
		chain.Add("Copy to target folder", build.CopyToTarget, false)
		chain.Add("Generate rk meta from on local", build.WriteRkMetaFile, false)
		chain.Add("Execute user script after", build.ExecScriptAfter, false)
		chain.Add("Execute user command after", build.ExecCommandsAfter, false)
	}

	chain.Add("Compress to tar.gz file", compressTarget, false)

	return chain.Execute(ctx)
}

func compressTarget(ctx *cli.Context) error {
	meta := common.GetRkMetaFromCmd()
	packName := fmt.Sprintf("%s-%s.tar.gz", meta.Name, meta.Version)

	args := []string{
		"-cvzf",
		packName,
		common.BuildTarget,
	}

	color.White("- tar %s", strings.Join(args, " "))

	bytes, err := exec.Command("tar", args...).CombinedOutput()
	if err != nil {
		os.RemoveAll(common.BuildTarget)
		return err
	}

	color.White(string(bytes))
	return nil
}
